/* * Copyright (C) 2015, Simon Fuhrmann * TU Darmstadt - Graphics, Capture and Massively Parallel Computing * All rights reserved. * * This software may be modified and distributed under the terms * of the BSD 3-Clause license. See the LICENSE.txt file for details. * * The surface reconstruction approach implemented here is described in: * *     Floating Scale Surface Reconstruction *     Simon Fuhrmann and Michael Goesele *     In: ACM ToG (Proceedings of ACM SIGGRAPH 2014). *     http://tinyurl.com/floating-scale-surface-recon */#include <cstdlib>#include <iostream>#include <string>#include "core/mesh.h"#include "core/mesh_io_ply.h"#include "util/timer.h"#include "util/arguments.h"#include "util/system.h"#include "surface/sample_io.h"#include "surface/iso_octree.h"#include "surface/iso_surface.h"#include "surface/hermite.h"#include "surface/defines.h"struct AppOptions{    std::vector<std::string> in_files;    std::string out_mesh;    int refine_octree = 0;    fssr::InterpolationType interp_type = fssr::INTERPOLATION_CUBIC;};//fssr::SampleIO::Options : //float scale_factor = 1;                            //float min_scale = -1;                            //float max_scale = -1;voidfssrecon (AppOptions const& app_opts, fssr::SampleIO::Options const& pset_opts){    /* Load input point set and insert samples in the octree. */    fssr::IsoOctree octree;    for (std::size_t i = 0; i < app_opts.in_files.size(); ++i) {        std::cout << "Loading: " << app_opts.in_files[i] << "..." << std::endl;        util::WallTimer timer;        /* Opens the input file for stream reading */        fssr::SampleIO loader(pset_opts);        loader.open_file(app_opts.in_files[i]);        fssr::Sample sample;        while (loader.next_sample(&sample)) {            octree.insert_sample(sample);            //当插入第一个采样点的时候,会创建一个新的八叉树,设置root_center=sample.pos,root_size = sample.scale,num_nodes = 1;判断第一个采样点与根节点尺度的差异符合要求，从而创建第一个node=root.            //当插入其他采样点时,判断采样点是否在八叉树外(以根节点为中心根节点尺度为棱长做cubic判断采样点在立方体内外),若在外部则拓展这个八叉树,直到容纳该采样点为止....            // 最后根据采样点的尺度和节点的立方体尺寸选择将采样点放置到哪个小立方体中        }        //至此,已经建立了一个八叉树并且将所有的点都放入了八叉树中.最终八叉树中的节点(都是叶子节点么)包含了所有采样点,每个node都会有部分采样点，所有的node中的采样点加起来就是输入的采样点.采样点根据node的尺寸和采样点尺度选择放入到哪个node中        std::cout << "Loading samples took "                  << timer.get_elapsed() << "ms." << std::endl;    }    /* 如果建立的八叉树中没有采样点那么表示导入失败 */    if (octree.get_num_samples() == 0) {        std::cerr << "Octree does not contain any samples, exiting."                  << std::endl;        std::exit(EXIT_FAILURE);    }    /* Refine octree if requested. Each iteration adds one level. */    if (app_opts.refine_octree > 0) {        std::cout << "Refining octree..." << std::flush;        util::WallTimer timer;        for (int i = 0; i < app_opts.refine_octree; ++i) {            octree.refine_octree();//通过细分所有叶子来细化八叉树。        }        std::cout << " took " << timer.get_elapsed() << "ms" << std::endl;    }    /** Compute voxels. **/    // cout << Limiting octree to 20 levels...;    //将层数超过预定层数的那些节点剔除,但是保留那些节点中存储的采样点并将他们放入到上一层节点中.    octree.limit_octree_level();    //打印八叉树中存储的采样点信息，包括每一层所包含的采样点数目等    octree.print_stats(std::cout);    // 计算所有叶子节点上8个体素顶点的符号距离值    octree.compute_voxels();    //由根节点出发遍历所有的节点，并清除节点中的采样点信息以及八叉树采样点数目置0    octree.clear_samples();    /*     * TODO print out signed distance function values     * */    /* Extract isosurface. */    core::TriangleMesh::Ptr mesh;    {        std::cout << "Extracting isosurface..." << std::endl;        util::WallTimer timer;        //iso_surface.octree = octree ,iso_surface.voxels = octree->get_voxels() , interpolation_type = INTERPOLATION_CUBIC        fssr::IsoSurface iso_surface(&octree, app_opts.interp_type);        //Computing Marching Cubes indices        //Computing isovertices        //Computing isopolygons        //Computing triangulation        mesh = iso_surface.extract_mesh();        std::cout << "  Done. Surface extraction took "                  << timer.get_elapsed() << "ms." << std::endl;    }    octree.clear();    /* 检查是否获得了网格模型 */    if (mesh->get_vertices().empty()) {        std::cerr << "Isosurface does not contain any vertices, exiting."                  << std::endl;        std::exit(EXIT_FAILURE);    }    /* Surfaces between voxels with zero confidence are ghosts. */    {        std::cout << "Deleting zero confidence vertices..." << std::flush;        util::WallTimer timer;        std::size_t num_vertices = mesh->get_vertices().size();        core::TriangleMesh::DeleteList delete_verts(num_vertices, false);        for (std::size_t i = 0; i < num_vertices; ++i)            if (mesh->get_vertex_confidences()[i] == 0.0f)                delete_verts[i] = true;        mesh->delete_vertices_fix_faces(delete_verts);        std::cout << " took " << timer.get_elapsed() << "ms." << std::endl;    }    /* Check for color and delete if not existing. */    core::TriangleMesh::ColorList& colors = mesh->get_vertex_colors();    if (!colors.empty() && colors[0].minimum() < 0.0f) {        std::cout << "Removing dummy mesh coloring..." << std::endl;        colors.clear();    }    /* Write output mesh. */    core::geom::SavePLYOptions ply_opts;    ply_opts.write_vertex_colors = true;    ply_opts.write_vertex_confidences = true;    ply_opts.write_vertex_values = true;    std::cout << "Mesh output file: " << app_opts.out_mesh << std::endl;    core::geom::save_ply_mesh(mesh, app_opts.out_mesh, ply_opts);}intmain (int argc, char** argv){    util::system::register_segfault_handler();    util::system::print_build_timestamp("Floating Scale Surface Reconstruction");    /* Setup argument parser. */    util::Arguments args;    args.set_exit_on_error(true);    args.set_nonopt_minnum(2);    args.set_helptext_indent(25);    args.set_usage(argv[0], "[ OPTS ] IN_PLY [ IN_PLY ... ] OUT_PLY");    args.add_option('s', "scale-factor", true, "Multiply sample scale with factor [1.0]");    args.add_option('r', "refine-octree", true, "Refines octree with N levels [0]");    args.add_option('\0', "min-scale", true, "Minimum scale, smaller samples are clamped");    args.add_option('\0', "max-scale", true, "Maximum scale, larger samples are ignored");#if FSSR_USE_DERIVATIVES    args.add_option('\0', "interpolation", true, "Interpolation: linear, scaling, lsderiv, [cubic]");#endif // FSSR_USE_DERIVATIVES    args.set_description("Samples the implicit function defined by the input "                         "samples and produces a surface mesh. The input samples must have "                         "normals and the \"values\" PLY attribute (the scale of the samples). "                         "Both confidence values and vertex colors are optional. The final "                         "surface should be cleaned (sliver triangles, isolated components, "                         "low-confidence vertices) afterwards.");    args.parse(argc, argv);    /* Init default settings. */    AppOptions app_opts;    fssr::SampleIO::Options pset_opts;    /* Scan arguments. */    while (util::ArgResult const* arg = args.next_result()) {        if (arg->opt == nullptr) {            app_opts.in_files.push_back(arg->arg);            continue;        }        if (arg->opt->lopt == "scale-factor")            pset_opts.scale_factor = arg->get_arg<float>();        else if (arg->opt->lopt == "refine-octree")            app_opts.refine_octree = arg->get_arg<int>();        else if (arg->opt->lopt == "min-scale")            pset_opts.min_scale = arg->get_arg<float>();        else if (arg->opt->lopt == "max-scale")            pset_opts.max_scale = arg->get_arg<float>();        else if (arg->opt->lopt == "interpolation") {            if (arg->arg == "linear")                app_opts.interp_type = fssr::INTERPOLATION_LINEAR;            else if (arg->arg == "scaling")                app_opts.interp_type = fssr::INTERPOLATION_SCALING;            else if (arg->arg == "lsderiv")                app_opts.interp_type = fssr::INTERPOLATION_LSDERIV;            else if (arg->arg == "cubic")                app_opts.interp_type = fssr::INTERPOLATION_CUBIC;            else {                args.generate_helptext(std::cerr);                std::cerr << std::endl << "Error: Invalid interpolation: "                          << arg->arg << std::endl;                return 1;            }        }        else {            std::cerr << "Invalid option: " << arg->opt->sopt << std::endl;            return EXIT_FAILURE;        }    }    if (app_opts.in_files.size() < 2) {        args.generate_helptext(std::cerr);        return EXIT_FAILURE;    }    app_opts.out_mesh = app_opts.in_files.back();    app_opts.in_files.pop_back();    if (app_opts.refine_octree < 0 || app_opts.refine_octree > 3) {        std::cerr << "Unreasonable refine level of "                  << app_opts.refine_octree << ", exiting." << std::endl;        return EXIT_FAILURE;    }    try    {        fssrecon(app_opts, pset_opts);    }    catch (std::exception& e)    {        std::cerr << "Error: " << e.what() << std::endl;        return EXIT_FAILURE;    }    std::cout << "All done. Remember to clean the output mesh." << std::endl;    return EXIT_SUCCESS;}