//// Created by caoqi on 2018/10/08.///* * Copyright (C) 2015, Simon Fuhrmann * TU Darmstadt - Graphics, Capture and Massively Parallel Computing * All rights reserved. * * This software may be modified and distributed under the terms * of the BSD 3-Clause license. See the LICENSE.txt file for details. */#include <iomanip>#include <iostream>#include <cstdlib>#include "mvs/settings.h"#include "mvs/dmrecon.h"#include "core/scene.h"#include "core/view.h"#include "util/timer.h"#include "util/arguments.h"#include "util/system.h"#include "util/tokenizer.h"#include "util/file_system.h"struct AppSettings{    std::string scene_path;    std::string ply_dest = "recon";    int master_id = -1;    std::vector<int> view_ids;    int max_pixels = 1500000;    bool force_recon = false;    bool write_ply = true;    mvs::Settings mvs;};/** * mvs: refViewNr = 0; imageEmbedding = "undistorted"; filterWidth = 5; minNCC = 0.3f; *      minParallax = 10.0f; acceptNCC = 0.6f; minRefineDiff = 0.001f; maxIterations = 20; nrReconNeighbors = 4; *      globalVSMax = 20; scale = argv[2]; useColorScale = true; writePlyFile = false; *      plyPath= "result1/recon"  ;  keepDzMap = false  ;keepConfidenceMap = false  ;quiet = false * * conf: scene_path=argv[1] ;ply_dest =recon ; master_id = argv[3] ; view_ids ; max_pixels = 1500000 ; force_recon = false ; write_ply = false **/intmain (int argc, char** argv){    if(argc<4){        std::cout<<"usage: scendir scale view_id"<<std::endl;        return -1;    }    AppSettings conf;        // 场景文件夹    conf.scene_path = argv[1];    // 获取图像尺度    std::stringstream stream1(argv[2]);//输入为2    stream1>>conf.mvs.scale;    // 获取重建视角id    std::stringstream stream2(argv[3]);    stream2>>conf.master_id;    conf.mvs.keepDzMap = true;    conf.mvs.keepConfidenceMap = true;    /* Load MVE scene. */    //里面包含了所有相机的参数信息（内外参）以及三维点的坐标位置、颜色、参考关系    std::cout<<"Loading scene..."<<std::endl;    core::Scene::Ptr scene;    try {        scene = core::Scene::create(conf.scene_path);//scene.basedir = result1        scene->get_bundle();//load_mve_bundle(../../synth_0.out)    }    catch (std::exception& e) {        std::cerr << "Error loading scene: " << e.what() << std::endl;        return EXIT_FAILURE;    }    /* Settings for Multi-view stereo */    //设置输出为.ply点云文件    conf.mvs.writePlyFile = conf.write_ply; //false    //保存.ply文件，其中包含vertices(pos), color和confidence,以及valid_vertex_id；    //保存.xf文件，其中包含从相机到世界坐标系的转换矩阵；    conf.mvs.plyPath = util::fs::join_path(conf.scene_path, conf.ply_dest);//result1/recon    //std::cout<<"writing ply file to "<<conf.mvs.plyPath<<std::endl;    util::WallTimer timer;    if (conf.master_id >= 0) {        std::cout << "Reconstructing view ID " << conf.master_id << std::endl;        conf.mvs.refViewNr = (std::size_t)conf.master_id;        try {            // 开始重建，conf.mvs中包含了需要重建的视图、畸变矫正后的图像，patch大小（5x5）等、scale（人为设定的图像尺度）            //为场景中的每一幅图像创建一个Single view;提取参考图像对应的SingleView 并创建图像金字塔;确定参考视图的target_level            // 以及对应的depth image, normal image, dz image, conf image图像尺寸,提取并输出需要重建的尺度的图像的尺寸            mvs::DMRecon recon(scene, conf.mvs);            recon.start();        }        catch (std::exception &err)        {            std::cerr << err.what() << std::endl;            return EXIT_FAILURE;        }    }    std::cout << "Reconstruction took "              << timer.get_elapsed() << "ms." << std::endl;    /* Save scene */    std::cout << "Saving views back to disc..." << std::endl;    scene->save_views();    return EXIT_SUCCESS;}